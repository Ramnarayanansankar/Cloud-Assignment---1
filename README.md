# ğŸš€ Assignment 1 â€“ Dockerized Python + PostgreSQL Stack

This project implements **Assignment 1 (ITCS 6190/8190)** using Docker.  
It demonstrates how to containerize a simple **PostgreSQL database** and a **Python app** that connects to the DB, performs queries, and writes results to a shared volume.

---

## ğŸ“‚ Project Structure
```
CloudAssignment/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ Dockerfile        # Python app image
â”‚   â””â”€â”€ main.py           # Python script that queries DB & writes summary
â”œâ”€â”€ db/
â”‚   â”œâ”€â”€ Dockerfile        # PostgreSQL image with init script
â”‚   â””â”€â”€ init.sql          # Schema + seed data (20 trips across 5 cities)
â”œâ”€â”€ out/                  # Host folder mounted into container (/out)
â”‚   â””â”€â”€ summary.json      # Output file (auto-generated by app)
â”œâ”€â”€ compose.yaml          # Docker Compose stack definition
â”œâ”€â”€ makefile              # Shortcuts: build, run, clean, etc.
â””â”€â”€ README.md             # Documentation (this file)
```

---

## ğŸ˜ Database (PostgreSQL)

- Runs PostgreSQL **16** inside a container.  
- Uses `init.sql` to **auto-create schema** and **insert seed data** on first start.  
- Data model:

```sql
CREATE TABLE trips (
  id SERIAL PRIMARY KEY,
  city TEXT NOT NULL,
  minutes INT NOT NULL,
  fare NUMERIC(6,2) NOT NULL
);
```

- Seeded with **20 trips** across 5 cities (Charlotte, New York, San Francisco, Chicago, Boston).

---

## ğŸ Application (Python)

- Runs inside a `python:3.11-slim` container.  
- Uses [psycopg3](https://www.psycopg.org/psycopg3/) to connect to PostgreSQL.  
- Reads DB connection info from **environment variables** (`DB_HOST`, `DB_PORT`, etc.).  
- Performs 3 queries:
  1. Count total number of trips.  
  2. Compute **average fare per city**.  
  3. Find **top N longest trips** by minutes (default `N=5`, configurable via `APP_TOP_N`).  

- Outputs:
  - Prints a JSON **summary** to stdout.  
  - Saves the same JSON into `out/summary.json` (via mounted volume).

---

## âš™ï¸ How to Run

### Option A â€“ Using `make`
From the project root:
```bash
make all
```
This will:
1. Stop any running containers.  
2. Clean and recreate the `out/` folder.  
3. Build images and start the stack.  

---

### Option B â€“ Using Docker Compose directly
```bash
docker compose up --build
```

---

## ğŸ“Š Example Output

When the app runs, it prints a JSON summary:

```json
{
  "total_trips": 20,
  "avg_fare_by_city": [
    {"city": "Boston", "avg_fare": 23.28},
    {"city": "Charlotte", "avg_fare": 18.41},
    {"city": "Chicago", "avg_fare": 24.65},
    {"city": "New York", "avg_fare": 24.55},
    {"city": "San Francisco", "avg_fare": 23.93}
  ],
  "top_by_minutes": [
    {"city": "New York", "minutes": 42, "fare": 45.2},
    {"city": "Boston", "minutes": 38, "fare": 36.25},
    {"city": "Charlotte", "minutes": 35, "fare": 32.4},
    {"city": "San Francisco", "minutes": 33, "fare": 35.8},
    {"city": "Chicago", "minutes": 31, "fare": 30.75}
  ]
}
```

This exact file is also saved under:
```
out/summary.json
```

---

## ğŸ›‘ How to Stop & Clean Up

```bash
# Stop containers & remove volumes
docker compose down -v

# Or use Makefile
make clean
```

---

## ğŸ”§ Troubleshooting

- **Error: `failed to read dockerfile`**  
  â†’ Ensure `db/Dockerfile` and `app/Dockerfile` exist.  

- **App says "Waiting for database..."**  
  â†’ Normal on startup; the app retries until the DB is healthy.  

- **Port conflict on 5432**  
  â†’ Stop local Postgres (`brew services stop postgresql`) or map to a different port in `compose.yaml`.  

- **No `summary.json` generated**  
  â†’ Ensure `out/` folder exists and is mounted (`volumes:` section in compose).  

- **Network timeout pulling images**  
  â†’ Restart Docker Desktop, switch to a stable network, or manually pull images:  
  ```bash
  docker pull postgres:16
  docker pull python:3.11-slim
  ```

---

## ğŸ“ Reflection

Through this assignment, I learned:
- How to containerize both **database and app layers**.  
- How to use **Docker Compose** for multi-service orchestration.  
- How to use **volumes** to share output between containers and host.  
- Importance of **healthchecks** and retry logic to ensure reliable startup.  

For future improvement, I would:
- Add unit tests for the Python logic.  
- Parameterize city filters and queries via environment variables.  
- Push images to a private Docker Hub repo for easier reuse.

---


